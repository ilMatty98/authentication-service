name: Quarkus CI/CD Pipeline - GraalVM Native Build (Java 17, Maven) # Name of the workflow

on:
  push: # Trigger the workflow on push events
    branches:
      - main  # Run the workflow only when there's a push to the 'main' branch

permissions:
  contents: write # Allows to write to the repository

jobs:
  build:
    runs-on: ubuntu-latest  # Specify the OS for the runner (ubuntu-latest)

    steps:
      # Step to check out the code from the repository
      - name: Checkout code the code from the repository
        uses: actions/checkout@v4

      # Step to Set up GraalVM 17
      - name: Set up GraalVM 17
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: '17.0.12'
          distribution: 'graalvm'
          native-image-job-reports: 'true'

      # Step to remove -SNAPSHOT suffix
      - name: Remove -SNAPSHOT suffix
        run: |
          # Extract current version from pom.xml
          CURRENT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)

          # Remove -SNAPSHOT suffix if present
          NEW_VERSION="${CURRENT_VERSION%-SNAPSHOT*}"

          # Update version in pom.xml without -SNAPSHOT
          mvn versions:set -DnewVersion=$NEW_VERSION -DgenerateBackupPoms=false

          # Export the new version as an environment variable for further use
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
        env:
          NEW_VERSION: ${{ env.new_version }}

      # Step to Commit, Tag, Push and Create Pull Request
      - name: Commit, Tag, Push and Create Pull Request
        run: |
          # Set up Git config
          git config --global user.email "${{ secrets.GIT_HUB_EMAIL }}"
          git config --global user.name "${{ secrets.GIT_HUB_NAME }}"

          # Ensure the main branch is up to date
          git checkout main
          git pull origin main

          # Create a new branch for the changes
          git checkout -b version-update-${{ env.NEW_VERSION }}

          # Commit changes to pom.xml
          git add pom.xml
          git commit -m "Upgrade version to ${{ env.NEW_VERSION }}"

          # Create a new tag
          git tag -a "v${{ env.NEW_VERSION }}" -m "Release version ${{ env.NEW_VERSION }}"

          # Push the new branch and the tag
          git push origin version-update-${{ env.NEW_VERSION }} --tags

          # Create a Pull Request to merge changes into main
          gh pr create --base main --head version-update-${{ env.NEW_VERSION }} --title "Release version ${{ env.NEW_VERSION }}" --body "Version update to ${{ env.NEW_VERSION }}"

          # Clean up: delete the local branch after push
          git branch -D version-update-${{ env.NEW_VERSION }}

          # Clean up: delete the remote branch after pull request is merged or closed
          git push origin --delete version-update-${{ env.NEW_VERSION }}

          # Optional: Remove the worktree if used
          git worktree remove /home/runner/work/***/***
        env:
          GITHUB_TOKEN: ${{ secrets.GIT_HUB_TOKEN }}  # Token for authentication
          NEW_VERSION: ${{ env.NEW_VERSION }}  # The new version calculated earlier

      # Step to Cache Maven dependencies
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository  # Path to the cache location (where Maven stores dependencies)
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}  # Unique cache key based on OS and pom.xml content
          restore-keys: |
            ${{ runner.os }}-maven-  # Fallback key based on OS only

      # Step to run tests in native mode with Maven and generate a coverage report with Jacoco
      - name: Run tests in native mode with Maven and generate a coverage report with Jacoco
        run: mvn clean verify jacoco:report -Pnative

      # Step to perform code quality analysis with SonarQube
      - name: Perform code quality analysis with SonarQube
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}  # Authentication token for SonarQube
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}  # URL of the SonarQube server
        with:
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.branch.name=master
            -Dsonar.java.binaries=target/classes
            -Dsonar.sources=src
            -Dsonar.coverage.exclusions=**/test/**/*
            -Dsonar.exclusions=**/test/**/*

      # Step to wait for SonarQube Quality Gate results
      - name: Wait for SonarQube Quality Gate results
        uses: sonarsource/sonarqube-quality-gate-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      # Step to extract version from pom.xml
      - name: Extract version from pom.xml
        id: get_version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      # Step to build Docker image
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ secrets.DOCKER_HUB_REPOSITORY_NAME }}:${{ env.VERSION }} .
        env:
          DOCKER_BUILDKIT: 1  # Optional for enhanced Docker build performance
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          DOCKER_HUB_REPOSITORY_NAME: ${{ secrets.DOCKER_HUB_REPOSITORY_NAME }}

      # Step to push Docker image to Docker Hub
      - name: Push Docker image to Docker Hub
        run: |
          docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} -p ${{ secrets.DOCKER_HUB_TOKEN }}
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ secrets.DOCKER_HUB_REPOSITORY_NAME }}:${{ env.VERSION }}
        env:
          DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          DOCKER_HUB_REPOSITORY_NAME: ${{ secrets.DOCKER_HUB_REPOSITORY_NAME }}